<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
        Document
    </title>
    <link rel='stylesheet' href=../../../css/prism.css /><link rel='stylesheet' href=../../../css/index.css />
    <link rel="icon" href="https://raw.githubusercontent.com/learner-lu/picbed/master/logo.png">
</head>

<body class="light">
    <div class='markdown-body'><h1>隐含规则</h1><ul><li>AR : 函数库打包程序。默认命令是 ar</li></ul><ul><li>AS : 汇编语言编译程序。默认命令是 as</li></ul><ul><li>CC : C 语言编译程序。默认命令是 cc</li></ul><ul><li>CXX : C++ 语言编译程序。默认命令是 g++</li></ul><ul><li>CO : 从 RCS 文件中扩展文件程序。默认命令是 co</li></ul><ul><li>CPP : C 程序的预处理器（输出是标准输出设备）。默认命令是 $(CC) –E</li></ul><ul><li>FC : Fortran 和 Ratfor 的编译器和预处理程序。默认命令是 f77</li></ul><ul><li>GET : 从 SCCS 文件中扩展文件的程序。默认命令是 get</li></ul><ul><li>LEX : Lex 方法分析器程序（针对于 C 或 Ratfor）。默认命令是 lex</li></ul><ul><li>PC : Pascal 语言编译程序。默认命令是 pc</li></ul><ul><li>YACC : Yacc 文法分析器（针对于 C 程序）。默认命令是 yacc</li></ul><ul><li>YACCR : Yacc 文法分析器（针对于 Ratfor 程序）。默认命令是 yacc –r</li></ul><ul><li>MAKEINFO : 转换 Texinfo 源文件（.texi）到 Info 文件程序。默认命令是 makeinfo</li></ul><ul><li>TEX : 从 TeX 源文件创建 TeX DVI 文件的程序。默认命令是 tex</li></ul><ul><li>TEXI2DVI : 从 Texinfo 源文件创建军 TeX DVI 文件的程序。默认命令是 texi2dvi</li></ul><ul><li>WEAVE : 转换 Web 到 TeX 的程序。默认命令是 weave</li></ul><ul><li>CWEAVE : 转换 C Web 到 TeX 的程序。默认命令是 cweave</li></ul><ul><li>TANGLE : 转换 Web 到 Pascal 语言的程序。默认命令是 tangle</li></ul><ul><li>CTANGLE : 转换 C Web 到 C。默认命令是 ctangle</li></ul><ul><li>RM : 删除文件命令。默认命令是 rm –f</li></ul><ul><li>ARFLAGS : 函数库打包程序 AR 命令的参数。默认值是 rv</li></ul><ul><li>ASFLAGS : 汇编语言编译器参数。（当明显地调用 .s 或 .S 文件时）</li></ul><ul><li>CFLAGS : C 语言编译器参数。</li></ul><ul><li>CXXFLAGS : C++ 语言编译器参数。</li></ul><ul><li>COFLAGS : RCS 命令参数。</li></ul><ul><li>CPPFLAGS : C 预处理器参数。（C 和 Fortran 编译器也会用到）。</li></ul><ul><li>FFLAGS : Fortran 语言编译器参数。</li></ul><ul><li>GFLAGS : SCCS “get”程序参数。</li></ul><ul><li>LDFLAGS : 链接器参数。（如：ld ）</li></ul><ul><li>LFLAGS : Lex 文法分析器参数。</li></ul><ul><li>PFLAGS : Pascal 语言编译器参数。</li></ul><ul><li>RFLAGS : Ratfor 程序的 Fortran 编译器参数。</li></ul><ul><li>YFLAGS : Yacc 文法分析器参数。</li></ul><h2>C</h2><p><a href="n" target="_blank">n</a>.o 的目标的依赖目标会自动推导为 <a href="n" target="_blank">n</a>.c ，并且其生成命令是 $(CC) –c $(CPPFLAGS)$(CFLAGS)</p><h2>C++</h2><p><a href="n" target="_blank">n</a>.o 的目标的依赖目标会自动推导为 <a href="n" target="_blank">n</a>.cc 或是 <a href="n" target="_blank">n</a>.C ，并且其生成命令是 $(CXX) –c$(CPPFLAGS) $(CXXFLAGS) 。（建议使用 .cc 作为 C++ 源文件的后缀，而不是 .C ）</p><h2>Pascal</h2><p><a href="n" target="_blank">n</a>.o 的目标的依赖目标会自动推导为 <a href="n" target="_blank">n</a>.p ，并且其生成命令是 $(PC) –c $(PFLAGS)</p><h2>Fortran/Ratfor</h2><h3>编译</h3><p><a href="n" target="_blank">n</a>.o 的目标的依赖目标会自动推导为 <a href="n" target="_blank">n</a>.r 或 <a href="n" target="_blank">n</a>.F 或 <a href="n" target="_blank">n</a>.f ，并且其生成命令是:</p><ul><li>.f $(FC) –c $(FFLAGS)</li></ul><ul><li>.F $(FC) –c $(FFLAGS) $(CPPFLAGS)</li></ul><ul><li>.f $(FC) –c $(FFLAGS) $(RFLAGS)</li></ul><h3>预处理</h3><p><a href="n" target="_blank">n</a>.f 的目标的依赖目标会自动推导为 <a href="n" target="_blank">n</a>.r 或 <a href="n" target="_blank">n</a>.F 。这个规则只是转换 Ratfor 或有预处理的Fortran 程序到一个标准的 Fortran 程序。其使用的命令是：</p><ul><li>.F $(FC) –F $(CPPFLAGS) $(FFLAGS)</li></ul><ul><li>.r $(FC) –F $(FFLAGS) $(RFLAGS)</li></ul><h2>Modula-2</h2><p><a href="n" target="_blank">n</a>.sym 的目标的依赖目标会自动推导为 <a href="n" target="_blank">n</a>.def ，并且其生成命令是：$(M2C) $(M2FLAGS)$(DEFFLAGS) 。<a href="n" target="_blank">n</a>.o 的目标的依赖目标会自动推导为 <a href="n" target="_blank">n</a>.mod ，并且其生成命令是：$(M2C)$(M2FLAGS) $(MODFLAGS)</p><h2>汇编和汇编预处理的隐含规则</h2><p><a href="n" target="_blank">n</a>.o 的目标的依赖目标会自动推导为 <a href="n" target="_blank">n</a>.s ，默认使用编译器 as ，并且其生成命令是：$ (AS)$(ASFLAGS) 。<a href="n" target="_blank">n</a>.s 的目标的依赖目标会自动推导为 <a href="n" target="_blank">n</a>.S ，默认使用 C 预编译器 cpp ，并且其生成命令是：$(AS) $(ASFLAGS)</p><h2>链接 Object 文件的隐含规则</h2><p><a href="n" target="_blank">n</a> 目标依赖于 <a href="n" target="_blank">n</a>.o ，通过运行 C 的编译器来运行链接程序生成（一般是 ld ），其生成命令是：$(CC) $(LDFLAGS) <a href="n" target="_blank">n</a>.o $(LOADLIBES) $(LDLIBS) 。这个规则对于只有一个源文件的工程有效，同时也对多个 Object 文件（由不同的源文件生成）的也有效。例如如下规则</p><pre><code class="language-Makefile">x : y.o z.o</code></pre><p>并且 x.c 、y.c 和 z.c 都存在时，隐含规则将执行如下命令</p><pre><code class="language-Makefile">cc -c x.c -o x.o
cc -c y.c -o y.o
cc -c z.c -o z.o
cc x.o y.o z.o -o x
rm -f x.o
rm -f y.o
rm -f z.o</code></pre><p>如果没有一个源文件（如上例中的 x.c）和你的目标名字（如上例中的 x）相关联，那么，你最好写出自己的生成规则，不然，隐含规则会报错的</p><h2>Yacc C</h2><p><a href="n" target="_blank">n</a>.c 的依赖文件被自动推导为 n.y （Yacc 生成的文件），其生成命令是：$(YACC) $(YFALGS)。（“Yacc”是一个语法分析器，关于其细节请查看相关资料）</p><h2>Lex C</h2><p><a href="n" target="_blank">n</a>.c 的依赖文件被自动推导为 n.l（Lex 生成的文件），其生成命令是：$(LEX) $(LFALGS) 。（关于“Lex”的细节请查看相关资料）</p><h2>Lex Ratfor</h2><p><a href="n" target="_blank">n</a>.r 的依赖文件被自动推导为 n.l （Lex 生成的文件），其生成命令是：$(LEX) $(LFALGS) 。</p><h2>从 C 程序、Yacc 文件或 Lex 文件创建 Lint 库的隐含规则</h2><p><a href="n" target="_blank">n</a>.ln（lint 生成的文件）的依赖文件被自动推导为 n.c ，其生成命令是：$(LINT) $(LINTFALGS)$(CPPFLAGS) -i 。对于 <a href="n" target="_blank">n</a>.y 和 <a href="n" target="_blank">n</a>.l 也是同样的规则</p></div>
    <div class="dir-tree"><ul><li><a href="../../md-docs/README" >README</a></li></ul><ul><li><a href="../../md-docs/Makefile函数" >Makefile函数</a></li></ul><ul><li><a href="../../md-docs/常用函数" >常用函数</a></li></ul><ul><li><a href="../../md-docs/隐含规则" >隐含规则</a></li></ul><ul><li><a href="../../md-docs/make参数" >make参数</a></li></ul><ul><li><a href="../../md-docs/自动化变量" >自动化变量</a></li></ul></div>
    <div class="zood"><a class="" href="https://github.com/luzhixing12345/zood" target="_blank">zood</a></div>
    <script type="text/javascript" src="../../../js/next_front.js"></script><script>addLink("../../md-docs/常用函数","../../md-docs/make参数","ab")</script><script type="text/javascript" src="../../../js/change_mode.js"></script><script>addChangeModeButton("../../../img/sun.png","../../../img/moon.png")</script><script type="text/javascript" src="../../../js/copy_code.js"></script><script>addCodeCopy("../../../img/before_copy.png","../../../img/after_copy.png")</script><script type="text/javascript" src="../../../js/prism.js"></script><script type="text/javascript" src="../../../js/picture_preview.js"></script><script type="text/javascript" src="../../../js/check_box.js"></script>
    <script type="module">
        const codeBlocks = document.querySelectorAll('.language-mermaid');
        codeBlocks.forEach(codeBlock => {
            codeBlock.classList.remove('language-mermaid');
            codeBlock.classList.add('mermaid');
        });
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ startOnLoad: true });
    </script>
</body>

</html>